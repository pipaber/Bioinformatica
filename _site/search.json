[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Piero Palacios Bernuy",
    "section": "",
    "text": "English  Spanish\nThis blog is built with Quarto and deployed with Netlify. My blog posts are released under a Creative Commons Attribution-ShareAlike 4.0 International License\nIf my blog has helped you, you can buy me a coffee."
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "Piero Palacios Bernuy",
    "section": "Experience",
    "text": "Experience\nExperimental Designs | Statistical Data Analysis and Modeling | R | Python | Galaxy | High Performance Computing (HPC) | NGS data handling\nIn vitro culture of plants | Microbiology | Realtime PCR analysis | Genomic data analysis (DNA) | Transcriptomic analysis by RNA-Seq."
  },
  {
    "objectID": "about_es.html",
    "href": "about_es.html",
    "title": "Piero Palacios Bernuy",
    "section": "",
    "text": "English  Spanish\nEste blog está hecho con Quarto y desarrollado con Netlify. Los artículos de este blog son desarrollados bajo la licencia internacional Creative Commons Atribución-ShareAlike 4.0\nSi te ha sido de ayuda mi blog, puedes comprarme un ¡café!"
  },
  {
    "objectID": "about_es.html#experiencia",
    "href": "about_es.html#experiencia",
    "title": "Piero Palacios Bernuy",
    "section": "Experiencia",
    "text": "Experiencia\nDiseños experimentales | Análisis y modelamiento estadístico de datos | R | Python | Galaxy | High Performance Computing (HPC) | Manejos de datos NGS\nCultivo in vitro | Microbiología | Análisis por PCR en tiempo real | Análisis de datos genómicos (ADN) | Análisis transcriptómico de plantas por RNA-Seq."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bioinformatica",
    "section": "",
    "text": "Genomic Ranges\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\nBioconductor\n\n\n\n\nMás sobre rangos genómicos y aplicaciones\n\n\n\n\n\n\nJul 28, 2022\n\n\nPiero Palacios Bernuy\n\n\n\n\n\n\n  \n\n\n\n\n\nIntroducción a Genomic Ranges\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\nBioconductor\n\n\n\n\nUna pequeña introducción a los rangos genómicos\n\n\n\n\n\n\nJul 12, 2022\n\n\nPiero Palacios Bernuy\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/bioconductor-basico/index.html",
    "href": "posts/bioconductor-basico/index.html",
    "title": "Bioconductor básico",
    "section": "",
    "text": "Mi nombre es Piero Palacios, y esta es la primera de una serie de publicaciones que se enfocarán en enseñar los paquetes básicos de Bioconductor para el análisis genómico. Puedes leer más acerca de mí en la sección: Acerca de mí.\nLo primero que puede pasar por tu mente es: ¿Y qué es Bioconductor? ¿Para qué me serviría aprender sobre Bioconductor?\nBueno, si eres biólogo o trabajas con datos biológicos créeme que te va a servir bastante.\nAhora bien, la página web de Bioconductor nos dice lo siguiente:\n“La misión del proyecto Bioconductor es desarrollar, apoyar y difundir software libre de código abierto que facilite el análisis riguroso y reproducible de datos de ensayos biológicos actuales y emergentes. Estamos dedicados a construir una comunidad diversa, colaborativa y acogedora de desarrolladores y científicos de datos.”\nDicho en otras palabras, Bioconductor es similar al repositorio de paquetes de R, con la diferencia de que es un repositorio de softwares creado para el análisis de datos biológicos con enfoque en la reproducibilidad del análisis.\nCabe resaltar que la reproducibilidad de resultados en biología es un reto y, tener softwares enfocados en ayudar a aliviar ese problema, es un gran avance para las ciencias biológicas.\nEn fin, como ya te habrás percatado por el título, este post es una pequeña introducción a los rangos genómicos asi que ¡vamos al asunto!"
  },
  {
    "objectID": "posts/bioconductor-basico/index.html#rangos-genómicos",
    "href": "posts/bioconductor-basico/index.html#rangos-genómicos",
    "title": "Bioconductor básico",
    "section": "Rangos genómicos",
    "text": "Rangos genómicos\nLos pares de bases del ADN son enumerados del 1 hasta un número grande (podría ser más de 3 millones dependiendo de la especie). Estas enumeraciones nos ayudan a situarnos en regiones genómicas de interés como genes, regiones promotoras, regiones no codificantes, etc.\nDicho esto, ya podemos definir qué es un rango genómico. Un rango genómico es simplemente una región del ADN delimitada por dos números enteros o “coordenadas genómicas” que son de un interés específico para el investigador.\nAhora bien, dedicaremos esta serie de artículos a los rangos genómicos con datos inventados y con datos provenientes de un experimento de precipitación de inmuno cromatina (ChIP-Seq). Esta técnica tiene por objetivo secuenciar regiones específicas del genoma que son sitios de unión de proteínas como factores de transcripción.\nLa pregunta siguiente sería: ¿Para qué nos sirve secuenciar éstas regiones? La respuesta dicha de manera resumida es: “depende”. Si lo sé, nada científico. Lo que sucede es que dependen del objetivo, por ejemplo: estudiar el cáncer de mama o efectos en el sabor del plátano. Para el caso del cáncer, es de interés encontrar a los genes cercanos a éstas regiones, ya que pueden ser motivo de tratamientos o cura. Es ahí donde entran los rangos genómicos al conocer la ubicación estas regiones cercanas a los genes.\nAntes de empezar a explorar los paquetes de Bioconductor, necesitamos instalarlos:\nBiocManager::install(\"IRanges\") BiocManager::install(\"GenomicRanges\") BiocManager::install(\"genomicsclass/ERBS\") install_github(\"genomicsclass/ph525x\")\nEn caso no tengas instalado Bioconductor, puedes instalarlo como lo mencionan en su página web: Instalar bioconductor\nHecho lo anterior, primero revisaremos el paquete IRanges el cual es la base del paquete GenomicRanges.\nPsdt: El material que se discutirá está inspirado en el libro online Data analysis for genomics de Rafael Irrizary y Michael Love. ¡Te recomiendo revisarlo!"
  },
  {
    "objectID": "posts/bioconductor-basico/index.html#paquete-iranges",
    "href": "posts/bioconductor-basico/index.html#paquete-iranges",
    "title": "Bioconductor básico",
    "section": "Paquete IRanges",
    "text": "Paquete IRanges\n\nlibrary(IRanges) # carguemos el paquete\n\nLa primera función que estudiaremos es IRanges(). La función tiene tres argumentos principales: inicio (start), fin (end) y ancho (width). Por ejemplo, si definimos un rango \\([8,14] = 8,9,10,11,12,13,14\\) este tendrá un ancho o width de siete números.\n\nrango<- IRanges(8,14)\nrango\n\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]         8        14         7\n\n\nPodemos extraer información como el inicio, el final y el ancho:\n\nstart(rango)\n\n[1] 8\n\nend(rango)\n\n[1] 14\n\nwidth(rango)\n\n[1] 7\n\n\nTambién podemos definir varios rangos al mismo tiempo:\n\nIRanges(start = c(2,4,7),end = c(10,15,14))\n\nIRanges object with 3 ranges and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]         2        10         9\n  [2]         4        15        12\n  [3]         7        14         8\n\n\n\nOperaciones intra-rangos\nLas operaciones intra-rangos funcionan sobre cada rango de manera independiente.Entre las operaciones intra-rangos podemos mencionar a narrow, shift, flank y resize. Existen otras operaciones intra-rangos que pueden verse en la ayuda ?intra-range-methods.\n\nlibrary(rafalib)\nmypar(7,1)\n\nnarrow(rango,start = 3) # encoge el rango desde el inicio\n\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]        10        14         5\n\nplotRanges(rango,xlim = c(1,18))\nplotRanges(narrow(rango,start = 3),xlim = c(1,18),col=\"midnightblue\")\n\nshift(rango,shift = -3) # mover el rango 3 pares de bases a la izquierda\n\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]         5        11         7\n\nplotRanges(shift(rango,shift = -3),xlim = c(1,18),col=\"midnightblue\")\n\n\nflank(rango,width = 3,start = T,both = F) # rodea el rango con 3 pares de bases a partir del inicio\n\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]         5         7         3\n\nplotRanges(flank(rango,width = 3,start = T,both = F),xlim = c(1,18),col=\"midnightblue\")\n\nflank(rango,width = 3,start = F,both = F) # rodea el rango con 3 pares de bases a partir del final\n\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]        15        17         3\n\nplotRanges(flank(rango,width = 3,start = F,both = F),xlim = c(1,18),col=\"midnightblue\")\n\nflank(rango,width = 3,start = T,both = T) # rodea el rango con 3 pares de bases para la izquierda y para la derecha a partir del inicio\n\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]         5        10         6\n\nplotRanges(flank(rango,width = 3,start = T,both = T),xlim = c(1,18),col=\"midnightblue\")\n\nresize(rango,width = 1) # redimensiona el rango a una base.\n\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]         8         8         1\n\nplotRanges(resize(rango,width = 1),xlim = c(1,18),col=\"midnightblue\")\n\n\n\n\n\n\nOperaciones inter-rangos\nA diferencia de las operaciones intra-rangos, las operaciones inter-rangos trabajan sobre un conjunto de rangos, y el resultado depende de todos los rangos.\nVeamos cómo funcionan:\n\nrangos<-IRanges(start = c(2,8,11,10),end = c(5,10,14,13))\n\nmypar(6,1)\n\nplotRanges(rangos,xlim = c(0,15))\n\nrange(rangos) # da el rango de inicio a fin de todos los rengos\n\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]         2        14        13\n\nplotRanges(range(rangos),xlim = c(0,15),col=\"midnightblue\")\n\nIRanges::reduce(rangos) # colapsa los rangos sobrepuestos en uno solo\n\nIRanges object with 2 ranges and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]         2         5         4\n  [2]         8        14         7\n\nplotRanges(IRanges::reduce(rangos),xlim = c(0,15),col=\"midnightblue\")\n\ngaps(rangos) # retorna el rango que no cubre ningún rango\n\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]         6         7         2\n\nplotRanges(gaps(rangos),xlim = c(0,15),col=\"midnightblue\")\n\ndisjoin(rangos) # retorna el máximo número de rangos no sobrepuestos\n\nIRanges object with 5 ranges and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]         2         5         4\n  [2]         8         9         2\n  [3]        10        10         1\n  [4]        11        13         3\n  [5]        14        14         1\n\nplotRanges(disjoin(rangos),xlim = c(0,15),col=\"midnightblue\")\n\n\n\n\nAhora que comprendemos las funciones básicas del paquete IRanges, es momento de identificar en qué se diferencia un rango y un rango genómico."
  },
  {
    "objectID": "posts/bioconductor-basico/index.html#genomicranges",
    "href": "posts/bioconductor-basico/index.html#genomicranges",
    "title": "Bioconductor básico",
    "section": "GenomicRanges",
    "text": "GenomicRanges\nLos rangos genómicos adicionalmente a los rangos que hemos visto, contienen dos partes esenciales de información: el nombre del cromosoma y la direccionalidad de la hebra de ADN (+, - o * so no se especifica).\n\nlibrary(GenomicRanges)\n\nEmpecemos por crear tres rangos genómicos pertenecientes al cromosoma 21 de la especie Homo sapiens. Supogamos que estos rangos pertenecen al genoma T2T-CHM13v2.0 el cual es la anotación telómero a telómero. Cabe resaltar que éstos rangos son inventados ya que no estamos usando una base de datos real.\n\ngr<-GRanges(\"chr21\",IRanges(start = c(5,12,14),end=c(25,31,40)),\n            strand = \"+\",seqlengths = c(chr21=100L))\n\ngenome(gr)<-\"T2T-CHM13v2.0\"\n\ngr\n\nGRanges object with 3 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21      5-25      +\n  [2]    chr21     12-31      +\n  [3]    chr21     14-40      +\n  -------\n  seqinfo: 1 sequence from T2T-CHM13v2.0 genome\n\nseqnames(gr)\n\nfactor-Rle of length 3 with 1 run\n  Lengths:     3\n  Values : chr21\nLevels(1): chr21\n\nseqlengths(gr)\n\nchr21 \n  100 \n\n\nUsemos las funciones de rangos sobre el rango genómico creado.\n\nshift(gr,10)\n\nGRanges object with 3 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21     15-35      +\n  [2]    chr21     22-41      +\n  [3]    chr21     24-50      +\n  -------\n  seqinfo: 1 sequence from GRCh38.p14 genome\n\nshift(gr,80)\n\nGRanges object with 3 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21    85-105      +\n  [2]    chr21    92-111      +\n  [3]    chr21    94-120      +\n  -------\n  seqinfo: 1 sequence from GRCh38.p14 genome\n\n\nCuando usamos shift() con 80 pares de bases, los rangos sobrepasan la longitud del cromosoma que es 100. Para evitar que suceda esto usemos trim().\n\ntrim(shift(gr,80))\n\nGRanges object with 3 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21    85-100      +\n  [2]    chr21    92-100      +\n  [3]    chr21    94-100      +\n  -------\n  seqinfo: 1 sequence from GRCh38.p14 genome\n\n\nFinalmente, la clase GRanges nos permite adicionar columnas de metadata con la función mcols().\n\nmcols(gr)\n\nDataFrame with 3 rows and 0 columns\n\nmcols(gr)$value<-c(0.1,0.9,0.003)\n\ngr\n\nGRanges object with 3 ranges and 1 metadata column:\n      seqnames    ranges strand |     value\n         <Rle> <IRanges>  <Rle> | <numeric>\n  [1]    chr21      5-25      + |     0.100\n  [2]    chr21     12-31      + |     0.900\n  [3]    chr21     14-40      + |     0.003\n  -------\n  seqinfo: 1 sequence from GRCh38.p14 genome\n\n#Incluso puede borrarse metadata\n\nmcols(gr)$value<-NULL\n\ngr\n\nGRanges object with 3 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21      5-25      +\n  [2]    chr21     12-31      +\n  [3]    chr21     14-40      +\n  -------\n  seqinfo: 1 sequence from GRCh38.p14 genome\n\n\nEn el siguiente artículo discutiremos más sobre la clase GRanges. Veremos la clase GRangesList donde formaremos listas de rangos genómicos, operaciones sobre estas listas, aplicaciones en datos reales de ChIP-Seq y le daremos sentido biológico a las operaciones de la clase IRanges."
  },
  {
    "objectID": "posts/GRanges List/index.html",
    "href": "posts/GRanges List/index.html",
    "title": "Bioconductor básico",
    "section": "",
    "text": "Mi nombre es Piero Palacios, y esta es la segunda parte de una serie de publicaciones que se enfocarán en enseñar el uso de rangos genómicos en R. Puedes leer más acerca de mí en la sección: Acerca de mí.\nEn el artículo anterior aprendimos sobre la clase IRanges, definimos que es un rango genómico, vimos cómo crear uno y aplicamos operaciones simples sobre éstos.\nLo siguiente es aprender sobre la clase GRangeList así que empecemos."
  },
  {
    "objectID": "posts/GRanges List/index.html#listas-de-rangos-genónimos",
    "href": "posts/GRanges List/index.html#listas-de-rangos-genónimos",
    "title": "Bioconductor básico",
    "section": "Listas de rangos genónimos",
    "text": "Listas de rangos genónimos\nAntes de empezar con los códigos, es momento de darle más contexto biológico a los rangos genómicos. Como hemos visto, un rango genómico es la coordenada de una secuencia de interés dentro del genoma.\nSi estas secuencias de interés son genes, es mucho más útil usar listas de rangos genómicos debido a que se pueden representar, de manera ordenada, grupos de interés dentro de cada gen; por ejemplo: listas de genes y dentro de cada gen, un objeto del tipo rango genómico en el cual están los exones.\n\n\n\n\n\nVeamos un ejemplo para entender a qué nos referimos con grupos de interés dentro de cada gen.\nPrimero creemos dos rangos genómicos:\n\nlibrary(GenomicRanges)\ngr1<-GRanges(\"chr21\",IRanges(start = c(5,12,14),end=c(25,31,40)),\n            strand = \"+\",seqlengths = c(chr21=100L))\ngr2<-GRanges(\"chr21\",IRanges(start = c(27,30),end=c(40,60)),\n            strand = \"+\",seqlengths = c(chr21=100L))\n\ngrl<-GRangesList(gr1,gr2)\ngrl\n\nGRangesList object of length 2:\n[[1]]\nGRanges object with 3 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21      5-25      +\n  [2]    chr21     12-31      +\n  [3]    chr21     14-40      +\n  -------\n  seqinfo: 1 sequence from an unspecified genome\n\n[[2]]\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21     27-40      +\n  [2]    chr21     30-60      +\n  -------\n  seqinfo: 1 sequence from an unspecified genome\n\n\nPodemos entender a grl como una lista de dos genes o dos transcriptos, y dentro de cada gen o transcripto tenemos diferente cantidad de exones.\nSe puede ver la longitud de la lista, la cantidad de elementos dentro de cada elemento de la lista e incluso podemos escoger solo ver un elemento de la lista.\n\nlength(grl)\n\n[1] 2\n\nelementNROWS(grl)\n\n[1] 3 2\n\ngrl[[1]]\n\nGRanges object with 3 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21      5-25      +\n  [2]    chr21     12-31      +\n  [3]    chr21     14-40      +\n  -------\n  seqinfo: 1 sequence from an unspecified genome\n\n\nTambién se puede agregar columnas de metadatos:\n\nmcols(grl)$values<-c(4,5)\n\ngrl\n\nGRangesList object of length 2:\n[[1]]\nGRanges object with 3 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21      5-25      +\n  [2]    chr21     12-31      +\n  [3]    chr21     14-40      +\n  -------\n  seqinfo: 1 sequence from an unspecified genome\n\n[[2]]\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21     27-40      +\n  [2]    chr21     30-60      +\n  -------\n  seqinfo: 1 sequence from an unspecified genome\n\n\nSin embargo, al escribir el objeto grl en la consola no muestra los metadatos. La forma correcta de verlos es usando la función mcols().\n\nmcols(grl)\n\nDataFrame with 2 rows and 1 column\n     values\n  <numeric>\n1         4\n2         5\n\n\nUna vez creados conjuntos de rangos genómicos o de listas de rangos genómicos, podría nacer esta pregunta: ¿Tienen rangos que se solapan?\nPara esta pregunta tenemos una función llamada findOverlaps(), que como dice el nombre, encuentra las secuencias que se solapan entre dos rangos o listas genómicas.\n\nov<-findOverlaps(gr1,gr2)\nov\n\nHits object with 4 hits and 0 metadata columns:\n      queryHits subjectHits\n      <integer>   <integer>\n  [1]         2           1\n  [2]         2           2\n  [3]         3           1\n  [4]         3           2\n  -------\n  queryLength: 3 / subjectLength: 2\n\n\nLo que nos dice el objeto ov es por ejemplo: el segundo rango de gr1 se solapa con el primer rango de gr2.\nOtra forma de hacer esta operación es con %over%. Esta operación nos retorna resultados lógicos del tipo TRUE o FALSE para el primer rango.\n\ngr1 %over% gr2\n\n[1] FALSE  TRUE  TRUE\n\n\nEstos resultados lógicos nos permiten filtrar los rangos que se solapan de la siguiente manera:\n\ngr1[gr1 %over% gr2]\n\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]    chr21     12-31      +\n  [2]    chr21     14-40      +\n  -------\n  seqinfo: 1 sequence from an unspecified genome\n\n\nHasta el momento sabemos crear rangos genómicos ya sea individuales o en listas y aprendimos sobre operaciones que se les pueden hacer a estos rangos. Ahora usemos los que aprendimos hasta ahora en datos reales de ChIP-Seq extraídos de células mamarias usadas para estudiar el cáncer de mama."
  },
  {
    "objectID": "posts/GRanges List/index.html#aplicación-en-datos-reales",
    "href": "posts/GRanges List/index.html#aplicación-en-datos-reales",
    "title": "Bioconductor básico",
    "section": "Aplicación en datos reales",
    "text": "Aplicación en datos reales\nPrimero carguemos los datos de dos líneas celulares usadas para estudiar sitios de unión de proteínas receptoras de estrógeno:\n\nlibrary(ERBS)\n\ndata(\"GM12878\")\ndata(\"HepG2\")\n\nBien lo primero que podemos hacer es ver los metadatos y los rangos genómicos.\n\nmcols(HepG2)\n\nDataFrame with 303 rows and 7 columns\n         name     score       col signalValue    pValue      qValue      peak\n    <numeric> <integer> <logical>   <numeric> <numeric>   <numeric> <integer>\n1          NA         0        NA      58.251    75.899 6.14371e-72       195\n2          NA         0        NA      10.808    69.685 5.02806e-66       321\n3          NA         0        NA      17.103    54.311 7.93067e-51       930\n4          NA         0        NA      12.427    43.855 1.35976e-40       604\n5          NA         0        NA      10.850    40.977 7.33386e-38       492\n...       ...       ...       ...         ...       ...         ...       ...\n299        NA         0        NA       9.681    10.057 1.42334e-08       402\n300        NA         0        NA       7.929    10.047 1.44208e-08       197\n301        NA         0        NA       5.864     9.990 1.63892e-08       227\n302        NA         0        NA       5.660     9.948 1.79941e-08       211\n303        NA         0        NA      13.211     9.918 1.92180e-08       163\n\ngranges(HepG2)\n\nGRanges object with 303 ranges and 0 metadata columns:\n        seqnames              ranges strand\n           <Rle>           <IRanges>  <Rle>\n    [1]     chr2   20335378-20335787      *\n    [2]    chr20       328285-329145      *\n    [3]     chr6 168135432-168136587      *\n    [4]    chr19     1244419-1245304      *\n    [5]    chr11   64071828-64073069      *\n    ...      ...                 ...    ...\n  [299]     chr4     1797182-1797852      *\n  [300]     chr1 110198573-110199126      *\n  [301]    chr17   17734052-17734469      *\n  [302]     chr1   48306453-48306908      *\n  [303]    chr12 123867207-123867554      *\n  -------\n  seqinfo: 93 sequences (1 circular) from hg19 genome\n\n\nTambién se pueden hacer análisis exploratorios, por ejemplo hacer un histograma de el ancho de los rangos genómicos y ver el valor de la mediana:\n\na<-width(granges(HepG2))\nmedian_width<-median(a)\nmedian_width\n\n[1] 560\n\nas_tibble(a)%>%\n  ggplot(aes(x=value))+\n  geom_histogram(fill=\"midnightblue\",color=\"white\",bins = 25)+\n  labs(title = element_text(\"Histograma del ancho de rangos genómicos\"),\n       x=\"Ancho de rangos genómicos\")+\n  theme(plot.title = element_text(hjust = 0.5,face = \"bold\"))+\n  geom_vline(xintercept = median_width,colour=\"red\",size=1.5,lty=2)\n\n\n\n\nUsemos la función findOverlaps() para buscar a las secuencias consenso (en común) que tienen las dos líneas celulares:\n\nconsenso<-findOverlaps(HepG2,GM12878)\nconsenso\n\nHits object with 75 hits and 0 metadata columns:\n       queryHits subjectHits\n       <integer>   <integer>\n   [1]         1          12\n   [2]         2          78\n   [3]         4         777\n   [4]         5           8\n   [5]         8          13\n   ...       ...         ...\n  [71]       285         621\n  [72]       287         174\n  [73]       291        1855\n  [74]       294         512\n  [75]       300         144\n  -------\n  queryLength: 303 / subjectLength: 1873\n\nhepg2_consenso<-HepG2[queryHits(consenso)]\nhepg2_consenso\n\nGRanges object with 75 ranges and 7 metadata columns:\n       seqnames              ranges strand |      name     score       col\n          <Rle>           <IRanges>  <Rle> | <numeric> <integer> <logical>\n   [1]     chr2   20335378-20335787      * |        NA         0      <NA>\n   [2]    chr20       328285-329145      * |        NA         0      <NA>\n   [3]    chr19     1244419-1245304      * |        NA         0      <NA>\n   [4]    chr11   64071828-64073069      * |        NA         0      <NA>\n   [5]     chr2   16938364-16938840      * |        NA         0      <NA>\n   ...      ...                 ...    ... .       ...       ...       ...\n  [71]    chr12 118558730-118559158      * |        NA         0      <NA>\n  [72]     chr1   35331750-35332300      * |        NA         0      <NA>\n  [73]     chr1   26146200-26147004      * |        NA         0      <NA>\n  [74]     chr6   44224657-44225693      * |        NA         0      <NA>\n  [75]     chr1 110198573-110199126      * |        NA         0      <NA>\n       signalValue    pValue      qValue      peak\n         <numeric> <numeric>   <numeric> <integer>\n   [1]      58.251    75.899 6.14371e-72       195\n   [2]      10.808    69.685 5.02806e-66       321\n   [3]      12.427    43.855 1.35976e-40       604\n   [4]      10.850    40.977 7.33386e-38       492\n   [5]      12.783    38.004 5.36029e-35       255\n   ...         ...       ...         ...       ...\n  [71]       8.292    10.294 8.59089e-09       195\n  [72]      10.458    10.233 9.81822e-09       341\n  [73]       5.742    10.176 1.10429e-08       337\n  [74]       3.525    10.102 1.29621e-08       838\n  [75]       7.929    10.047 1.44208e-08       197\n  -------\n  seqinfo: 93 sequences (1 circular) from hg19 genome\n\n\nSe puede ver que sólo tienen 75 secuencias en común de sitios de unión de proteínas receptoras de estrógeno.\nHemos encontrado regiones que se solapan entre las dos líneas celulares; sin embargo, también es de interés buscar regiones que estén cerca a los sitios de unión de las proteínas receptoras de estrógeno. ¿Por qué? Porque al ser dos líneas celulares diferentes, los sitios de unión también difieren. Veamos cómo hacer esto:\n\ndist_prot<-distanceToNearest(HepG2,GM12878)\ndist_prot\n\nHits object with 303 hits and 1 metadata column:\n        queryHits subjectHits |  distance\n        <integer>   <integer> | <integer>\n    [1]         1          12 |         0\n    [2]         2          78 |         0\n    [3]         3         438 |    567101\n    [4]         4         777 |         0\n    [5]         5           8 |         0\n    ...       ...         ... .       ...\n  [299]       299        1260 |     58550\n  [300]       300         144 |         0\n  [301]       301         619 |    237981\n  [302]       302        1163 |   1491857\n  [303]       303         546 |     43816\n  -------\n  queryLength: 303 / subjectLength: 1873\n\n\nAdicionalmente a lo que vimos con la función findOverlaps(); la función distanceToNearest() calcula la distancia de los solapamientos y de las regiones que no se solapan. Como te habrás dado cuenta los solapamientos tienen distancia de cero y, son 303 regiones que pertencen a las 303 regiones de la línea celular HepG2."
  },
  {
    "objectID": "posts/GRanges List/index.html#más-datos-reales",
    "href": "posts/GRanges List/index.html#más-datos-reales",
    "title": "Bioconductor básico",
    "section": "Más datos reales",
    "text": "Más datos reales\nAdicionalmente a los datos reales que hemos estado analizando, usaremos un objeto de anotación que contiene información sobre los genes del ser humano.\nLa pregunta que podrías hacerte ahora es, ¿y a qué te refieres con un objeto de anotación?\nBueno, una imagen habla más así que primero veámoslo y verás que se explica solo:\n\nlibrary(Homo.sapiens)\n\nHomo.sapiens\n\nOrganismDb Object:\n# Includes GODb Object:  GO.db \n# With data about:  Gene Ontology \n# Includes OrgDb Object:  org.Hs.eg.db \n# Gene data about:  Homo sapiens \n# Taxonomy Id:  9606 \n# Includes TxDb Object:  TxDb.Hsapiens.UCSC.hg19.knownGene \n# Transcriptome data about:  Homo sapiens \n# Based on genome:  hg19 \n# The OrgDb gene id ENTREZID is mapped to the TxDb gene id GENEID .\n\n\nComo podrás ver, este objeto de anotación tiene información anotada de: Genes, Transcriptos (TxDb), el genoma en el que está basado (hg19), el código taxonómico e información de ontología de los genes.\nPuedes pensar en toda esta información almacenada en formato de tablas, a las que puedes acceder usando funciones específicas.\nPara empezar, en este post usaremos tres funciones que nos permitirán acceder a la información del objeto de anotación: genes(),exnosBy() y select() que como puedes intuir, extraen información sobre genes y exnoes. En artículos futuros ahondaremos más sobre los objetos de anotación, su creación y de la GRAN utilidad que tienen para acceder a la información genómica de interés.\nEmpecemos viendo el resultado de la función genes():\n\ngenes_hs <- genes(Homo.sapiens)\ngenes_hs\n\nGRanges object with 23056 ranges and 1 metadata column:\n        seqnames              ranges strand |          GENEID\n           <Rle>           <IRanges>  <Rle> | <CharacterList>\n      1    chr19   58858172-58874214      - |               1\n     10     chr8   18248755-18258723      + |              10\n    100    chr20   43248163-43280376      - |             100\n   1000    chr18   25530930-25757445      - |            1000\n  10000     chr1 243651535-244006886      - |           10000\n    ...      ...                 ...    ... .             ...\n   9991     chr9 114979995-115095944      - |            9991\n   9992    chr21   35736323-35743440      + |            9992\n   9993    chr22   19023795-19109967      - |            9993\n   9994     chr6   90539619-90584155      + |            9994\n   9997    chr22   50961997-50964905      - |            9997\n  -------\n  seqinfo: 93 sequences (1 circular) from hg19 genome\n\nlength(genes_hs)\n\n[1] 23056\n\n\nAhora puedes ver mucho más el por qué de la utilidad de los rangos genómicos. La anotación h19 del Homo sapiens cuenta con 23056 genes; específicamente podemos ver en qupe cromosoma se encuentran, sus coordenadas genómicas, el sentido en el que se encuentra y el código de identificación que poseen.\nTambién podemos ver a los exones por gen:\n\nexonsBy(Homo.sapiens,by = \"gene\")\n\nGRangesList object of length 23459:\n$`1`\nGRanges object with 15 ranges and 2 metadata columns:\n       seqnames            ranges strand |   exon_id   exon_name\n          <Rle>         <IRanges>  <Rle> | <integer> <character>\n   [1]    chr19 58858172-58858395      - |    250809        <NA>\n   [2]    chr19 58858719-58859006      - |    250810        <NA>\n   [3]    chr19 58859832-58860494      - |    250811        <NA>\n   [4]    chr19 58860934-58862017      - |    250812        <NA>\n   [5]    chr19 58861736-58862017      - |    250813        <NA>\n   ...      ...               ...    ... .       ...         ...\n  [11]    chr19 58868951-58869015      - |    250821        <NA>\n  [12]    chr19 58869318-58869652      - |    250822        <NA>\n  [13]    chr19 58869855-58869951      - |    250823        <NA>\n  [14]    chr19 58870563-58870689      - |    250824        <NA>\n  [15]    chr19 58874043-58874214      - |    250825        <NA>\n  -------\n  seqinfo: 93 sequences (1 circular) from hg19 genome\n\n$`10`\nGRanges object with 2 ranges and 2 metadata columns:\n      seqnames            ranges strand |   exon_id   exon_name\n         <Rle>         <IRanges>  <Rle> | <integer> <character>\n  [1]     chr8 18248755-18248855      + |    113603        <NA>\n  [2]     chr8 18257508-18258723      + |    113604        <NA>\n  -------\n  seqinfo: 93 sequences (1 circular) from hg19 genome\n\n...\n<23457 more elements>\n\n\nHagamos otro histograma del ancho de los rangos genómicos, pero esta vez a los genes del humano.\n\na<-width(genes_hs)\nmedian_width<-median(a)\nmedian_width\n\n[1] 20115.5\n\nas_tibble(a)%>%\n  ggplot(aes(x=value))+\n  geom_histogram(fill=\"midnightblue\",color=\"white\")+\n  labs(title = element_text(\"Histograma del ancho de rangos genómicos\"),\n       x=\"Ancho de rangos genómicos\")+\n  theme(plot.title = element_text(hjust = 0.5,face = \"bold\"))+\n  geom_vline(xintercept = median_width,colour=\"red\",size=1.5,lty=2)+\n  geom_vline(xintercept = median_width,colour=\"red\",size=1.5,lty=2)+\n  coord_cartesian(xlim = c(0,2.5e6))\n\n\n\n\nFinalmente, la siguiente pregunta es, ¿y como relaciono los genes del ser humano con los datos de ChIP-Seq?\nLa respuesta es simple, usando las funciones de solapamiento o similares. Puedes aprender más de ellas en la ayuda: ?distanceToNearest.\nPara demostrar el uso de éstas funciones sobre el genoma humano primero encontremos los sitios de inicio de la transcripción de los genes con una de las funciones de rangos genómicos: resize().\n\nsit<-resize(genes_hs,1)\nsit\n\nGRanges object with 23056 ranges and 1 metadata column:\n        seqnames    ranges strand |          GENEID\n           <Rle> <IRanges>  <Rle> | <CharacterList>\n      1    chr19  58874214      - |               1\n     10     chr8  18248755      + |              10\n    100    chr20  43280376      - |             100\n   1000    chr18  25757445      - |            1000\n  10000     chr1 244006886      - |           10000\n    ...      ...       ...    ... .             ...\n   9991     chr9 115095944      - |            9991\n   9992    chr21  35736323      + |            9992\n   9993    chr22  19109967      - |            9993\n   9994     chr6  90539619      + |            9994\n   9997    chr22  50964905      - |            9997\n  -------\n  seqinfo: 93 sequences (1 circular) from hg19 genome\n\n\nEs importante recordar que estas funciones dependen de la dirección en la que los genes se encuentran en la hebra doble del ADN.\nBien, hecho esto lo que sigue es: buscar a las regiones de unión de las proteinas receptoras de estrógeno que estén cerca a genes.\n¿Cómo hacemos esto? Con la función nearest().\nEnfoquémonos en las secuencias consenso de las dos líneas celulares. Estas ya la hallamos arriba y las guardamos como hepg2_consenso.\nEspecíficamente veamos a la cuarta región:\n\nind <-nearest(granges(hepg2_consenso)[4],sit)\nind\n\n[1] 6316\n\n\nLa cuarta región está cerca al gen 6316. Filtremos a este gen:\n\nsit[ind]\n\nGRanges object with 1 range and 1 metadata column:\n       seqnames    ranges strand |          GENEID\n          <Rle> <IRanges>  <Rle> | <CharacterList>\n  2101    chr11  64073044      + |            2101\n  -------\n  seqinfo: 93 sequences (1 circular) from hg19 genome\n\n\nPodemos ver que está en el cromosoma 11 y tiene el id del gen es 2101.\nAhora, ¿cómo averiguamos el nombre y símbolo del gen? Bueno esto es sencillo debido a que el objeto de anotación cuenta con esta información. Veamos cómo obtener el nombre y símbolo del gen:\n\n#Extraemos el código de identificación\ngen_de_interés<-as.character(mcols(sit)$GENEID[ind])\n\nselect(Homo.sapiens,keys = gen_de_interés,keytype = \"GENEID\",columns = c(\"SYMBOL\",\"GENENAME\"))\n\n  GENEID                        GENENAME SYMBOL\n1   2101 estrogen related receptor alpha  ESRRA\n\n\nPodemos ver que es un gen que tiene relación con la recepción de estrógeno, y ¡es lo que los investigadores buscaban al realizar el experimento de ChIP-Seq!\nEn el siguiente artículo discutiremos el manejo de secuencias de ADN como obtener el contenido de guanina-citocina, y cómo obtener secuencias específicas de rangos genómicos; por ejemplo: obtener la secuencia de un gen de interés."
  }
]